
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
(function () {
    'use strict';

    /**!
     @preserve Carbonium 0.1
     @copyright 2020 Edwin Martin
     @license MIT
     */
    function e(e,t){const o=(t||document).querySelectorAll(e);return new Proxy(o,n)}let t;const n={get(e,o){let l=null;if(o==Symbol.iterator)return function*(){for(let t=0;t<e.length;t++)yield e[t];};if("style"==o||"classList"==o){t=e;const l=Reflect.get(document.body,o);return new Proxy(l,n)}let r=null;if(e instanceof CSSStyleDeclaration&&(l=Reflect.get(document.body.style,o),r="style"),e instanceof DOMTokenList&&(l=Reflect.get(document.body.classList,o),r="classList"),r)return "function"==typeof l?new Proxy(l,{apply:function(e,o,l){return t.forEach(t=>{Reflect.apply(e,t[r],l);}),new Proxy(t,n)}}):l;if(Array.prototype.hasOwnProperty(o)){const e=Reflect.get(Array.prototype,o);if("function"==typeof e)return new Proxy(e,{apply:function(e,t,o){const l=Reflect.apply(e,t,o);return new Proxy(void 0!==l?l:t,n)}})}return e.length>0?o in e[0]&&(l=Reflect.get(e[0],o)):o in document.body&&(l=Reflect.get(document.body,o)),l?"function"==typeof l?new Proxy(l,{apply:function(e,t,n){let o=null,l=!0;for(const r of t){const t=Reflect.apply(e,r,n);l&&(o=t,l=!1);}return null!=o&&null!=o?o:t}}):l:Reflect.get(e,o)},set:(e,t,n)=>("forEach"in e?e.forEach(e=>{Reflect.set(e,t,n);}):Reflect.set(e,t,n),!0)};

    class s{constructor(){this.subscribers=new Set,this.subscribersHot=new Set,this.dispatched=!1,this.hot=!1;}dispatch(s){const t=this.val;this.val=s,this.dispatched=!0,this.subscribers.forEach(i=>i(s,t));}subscribeNext(s){return this.subscribers.add(s),this.notifyHotSubscribers(),{unsubscribe:()=>{this.subscribers.delete(s);}}}subscribe(s){return this.dispatched&&s(this.val),this.subscribeNext(s)}unsubscribe(s){this.subscribers.delete(s),this.notifyHotSubscribers();}notifyHotSubscribers(){this.subscribers.size>0!=this.hot&&(this.hot=this.subscribers.size>0,this.subscribersHot.forEach(s=>s(this.hot)));}subscribeHot(s){return this.subscribersHot.add(s),{unsubscribe:()=>{this.subscribersHot.delete(s);}}}clear(){this.subscribers.clear(),this.subscribersHot.clear();}value(){return this.val}promise(){return new Promise(s=>{const t=this.subscribe((function(i){t.unsubscribe(),s(i);}));})}map(t){const i=new s,e=s=>{i.dispatch(t(s));};return i.subscribeHot(s=>{s?this.subscribe(e):this.unsubscribe(e);}),i}filter(t){const i=new s,e=s=>{t(s)&&i.dispatch(s);};return i.subscribeHot(s=>{s?this.subscribe(e):this.unsubscribe(e);}),i}}function i(t,i){const e=new s,r=s=>{e.dispatch(s);};return e.subscribeHot(s=>{s?t.addEventListener(i,r,!1):t.removeEventListener(i,r,!1);}),e}function e$1(...t){const i=new s,e=new Set;return i.subscribeHot(s=>{s?t.forEach(s=>{e.add(s.subscribe(()=>{i.dispatch(t.map(s=>s.value()));}));}):e.forEach(s=>s.unsubscribe());}),i}

    class GofCanvas extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: flex;
          background: #7e7e7e;
        }
        #canvas{
          margin-left: var(--width-mod, 0);
        }
      </style>
      
      <canvas id="canvas"></canvas>
    `;
        }
        connectedCallback() {
            this.dimension$ = new s();
            this.click$ = new s();
            this.canvasDomElement = e('#canvas', this.shadowRoot);
            if (!this.canvasDomElement.getContext) {
                return;
            }
            try {
                let rect = this.canvasDomElement.getBoundingClientRect();
                this.offscreen = new OffscreenCanvas(rect.width, rect.height);
                this.ctx = this.offscreen.getContext('2d', { alpha: false });
                this.ctxOffscreen = this.canvasDomElement.getContext('bitmaprenderer');
            }
            catch (e) {
                this.ctx = this.canvasDomElement.getContext('2d', { alpha: false });
            }
            this.setCellSize(11);
            this.calculateDimensions();
        }
        init(redraw$, resize$, size$) {
            redraw$.subscribe((cells) => {
                this.draw(cells);
            });
            resize$.subscribe(() => {
                this.calculateDimensions();
            });
            size$.subscribe((newGridSize) => {
                this.setCellSize(newGridSize);
            });
            // TODO: this.click$ = â€¦
            i(this.canvasDomElement, 'click')
                .map((event) => {
                const canvasRect = this.canvasDomElement.getBoundingClientRect();
                return {
                    cellX: Math.floor((event.clientX - canvasRect.left - 2) / this.cellSize),
                    cellY: Math.floor((event.clientY - canvasRect.top - 3) / this.cellSize)
                };
            }).subscribe((event) => {
                this.click$.dispatch(event);
            });
        }
        draw(cells) {
            const ctx = this.ctx;
            const size = this.cellSize;
            ctx.fillStyle = "#7e7e7e";
            ctx.lineWidth = 1;
            ctx.fillRect(0, 0, this.canvasDomElement.width + this.cellSize, this.canvasDomElement.height);
            ctx.strokeStyle = "#999";
            for (let n = 0; n <= this.canvasDomElement.width; n += this.cellSize) {
                ctx.beginPath();
                ctx.moveTo(n + .5, 0);
                ctx.lineTo(n + .5, this.canvasDomElement.height);
                ctx.stroke();
            }
            for (let n = this.cellSize; n < this.canvasDomElement.height; n += this.cellSize) {
                ctx.beginPath();
                ctx.moveTo(0, n + .5);
                ctx.lineTo(this.canvasDomElement.width, n + .5);
                ctx.stroke();
            }
            ctx.fillStyle = "yellow";
            ctx.lineWidth = 1;
            cells.forEach(function (cell) {
                ctx.fillRect(cell[0] * size + 1, cell[1] * size + 1, size - 1, size - 1);
            });
            if (this.ctxOffscreen) {
                const bitmap = this.offscreen.transferToImageBitmap();
                this.ctxOffscreen.transferFromImageBitmap(bitmap);
            }
        }
        calculateDimensions() {
            const rect = this.canvasDomElement.getBoundingClientRect();
            const pixelWidth = document.documentElement.clientWidth;
            const widthMod = (pixelWidth % this.cellSize) / 2;
            this.canvasDomElement.style.setProperty('--width-mod', `${widthMod}px`);
            this.canvasDomElement.width = pixelWidth - pixelWidth % this.cellSize;
            this.canvasDomElement.height = rect.height;
            if (this.ctxOffscreen) {
                this.offscreen = new OffscreenCanvas(this.canvasDomElement.width, this.canvasDomElement.height);
                this.ctx = this.offscreen.getContext('2d', { alpha: false });
            }
            this.dimension$.dispatch({
                width: Math.floor(this.canvasDomElement.width / this.cellSize),
                height: Math.floor(this.canvasDomElement.height / this.cellSize)
            });
        }
        setCellSize(size) {
            this.cellSize = size;
            this.dimension$.dispatch({
                width: Math.floor(this.canvasDomElement.width / size),
                height: Math.floor(this.canvasDomElement.height / size)
            });
        }
    }
    customElements.define('gof-canvas', GofCanvas);

    class GofInfo extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `
      <style>
        :host {
          position: absolute;
          top: 150px;
          left: 10vw;
          width: 80vw;
          height: calc(100vh - 300px);
          background: white;
          border: 1px solid #666;
          box-shadow: #666 5px 5px 5px;
          z-index: 2000;
        }
        
        .info-content {
          overflow: scroll;
          overflow-scrolling: touch;
          -webkit-overflow-scrolling: touch;
          height: calc(100vh - 300px);
          padding: 1em;
        }
        
        .close-button {
          position: absolute;
          width: 22px;
          height: 20px;
          right: 0.5em;
          top: 0.5em;
          background: url(pix/close.svg) no-repeat;
        }
        
        section {
          background: white;
        }
      </style>
      
      <section>
        <button class="close-button" data-close aria-label="Close"></button>
        <div class="info-content">
          <slot></slot>
          <p class="center">
            <button data-close>Close</button>
          </p>
        </div>
      </section>
    `;
        }
        connectedCallback() {
            e$1(i(e('[data-close]', this.shadowRoot), 'click'), i(document.documentElement, 'keyup')
                .filter((event) => event.key == 'Escape'), i(document.documentElement, 'click')
                .filter(event => event.target.classList.contains('whitebox'))).subscribe(() => {
                this.setAttribute('hidden', '');
                document.body.classList.remove('whitebox');
            });
            i(document.documentElement, 'focusout')
                .filter((event) => event.target.closest("gof-info") != null)
                .subscribe(() => {
                e('.close-button', this.shadowRoot).focus();
                return false;
            });
        }
        init(info$) {
            info$.subscribe(() => {
                this.removeAttribute('hidden');
                document.body.classList.add('whitebox');
                e('.close-button', this.shadowRoot).focus();
            });
        }
    }
    customElements.define('gof-info', GofInfo);

    function gofNext(shape) {
        let neighbours = {};
        let newShape = [];
        shape.forEach((cell) => {
            let index;
            index = 'c' + (cell[0] - 1) + ',' + (cell[1] - 1);
            if (neighbours[index]) {
                neighbours[index].n++;
            }
            else {
                neighbours[index] = { n: 1, cell: [cell[0] - 1, cell[1] - 1] };
            }
            index = 'c' + (cell[0]) + ',' + (cell[1] - 1);
            if (neighbours[index]) {
                neighbours[index].n++;
            }
            else {
                neighbours[index] = { n: 1, cell: [cell[0], cell[1] - 1] };
            }
            index = 'c' + (cell[0] + 1) + ',' + (cell[1] - 1);
            if (neighbours[index]) {
                neighbours[index].n++;
            }
            else {
                neighbours[index] = { n: 1, cell: [cell[0] + 1, cell[1] - 1] };
            }
            index = 'c' + (cell[0] - 1) + ',' + (cell[1]);
            if (neighbours[index]) {
                neighbours[index].n++;
            }
            else {
                neighbours[index] = { n: 1, cell: [cell[0] - 1, cell[1]] };
            }
            index = 'c' + (cell[0] + 1) + ',' + (cell[1]);
            if (neighbours[index]) {
                neighbours[index].n++;
            }
            else {
                neighbours[index] = { n: 1, cell: [cell[0] + 1, cell[1]] };
            }
            index = 'c' + (cell[0] - 1) + ',' + (cell[1] + 1);
            if (neighbours[index]) {
                neighbours[index].n++;
            }
            else {
                neighbours[index] = { n: 1, cell: [cell[0] - 1, cell[1] + 1] };
            }
            index = 'c' + (cell[0]) + ',' + (cell[1] + 1);
            if (neighbours[index]) {
                neighbours[index].n++;
            }
            else {
                neighbours[index] = { n: 1, cell: [cell[0], cell[1] + 1] };
            }
            index = 'c' + (cell[0] + 1) + ',' + (cell[1] + 1);
            if (neighbours[index]) {
                neighbours[index].n++;
            }
            else {
                neighbours[index] = { n: 1, cell: [cell[0] + 1, cell[1] + 1] };
            }
        });
        shape.forEach(function (cell, i) {
            const index = 'c' + cell[0] + ',' + cell[1];
            if (neighbours[index]) {
                neighbours[index].populated = true;
            }
        });
        for (const index in neighbours) {
            if ((neighbours[index].n == 2 && neighbours[index].populated) || neighbours[index].n == 3) {
                newShape.push(neighbours[index].cell);
            }
        }
        return newShape;
    }

    class GofControls extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: flex;
          justify-content:  center;
          flex-wrap: wrap;
          align-items:  center;
        }
        
        img {
          vertical-align: bottom;
          margin-left: 30px;
        }
        
        :host > * {
          margin: 0 5vw;
        }
        
        form > * {
          margin: 10px 0;
        }
        
        input[type="range"] {
          width: 80px;
        }
        
        .generation {
          font-family: helvetica, arial, sans-serif;
          font-size: smaller;
          margin-left: 2em;
        }
        
        nowrap {
          white-space: nowrap;
        }
        
        nowrap > * {
          vertical-align: middle;
        }
      </style>
      
      <form>
        <select id="shapes" aria-label="Select predefined shape">
        </select>
        <input id="next" type="button" value="Next">
        <input id="start" type="button" value="Start">
        <label class="generation" title="Generations" aria-label="Generations">0</label>
        <nowrap>
          <img src="pix/speeddial.svg" alt="" width="20" height="20">
          <input id="speed" type="range" min="0" max="100" value="50" title="Speed dial" aria-label="Speed dial">
        </nowrap>
        <nowrap>
          <img src="pix/grid.svg" alt="" width="20" height="20">
          <input id="size" type="range" min="0" max="100" value="58" title="Grid size" aria-label="Grid size">
        </nowrap>
        <input id="info" type="button" value="Explanation">
      </form>
    `;
        }
        connectedCallback() {
            this.started = false;
            this.timer = null;
            this.generation = 0;
            this.collection = this.getCollection();
            this.newShape$ = new s();
            this.nextShape$ = new s();
            this.nextGeneration$ = new s();
            this.resize$ = i(window, 'resize');
        }
        init(redraw$, toggle$) {
            this.redraw$ = redraw$;
            this.info$ = i(e('#info', this.shadowRoot), 'click');
            toggle$.subscribe(() => {
                this.setGeneration(0);
            });
            const shapesSelect = e('#shapes', this.shadowRoot);
            this.collection.forEach((shape) => {
                const option = document.createElement('option');
                option.text = shape.name;
                shapesSelect.appendChild(option);
            });
            i(shapesSelect, 'change').subscribe((event) => {
                this.setGeneration(0);
                this.newShape$.dispatch(this.collection[event.target.selectedIndex].data);
            });
            e('#shapes', this.shadowRoot).selectedIndex = 1;
            this.newShape$.dispatch(this.collection[1].data);
            this.nextGeneration$ = i(e('#next', this.shadowRoot), 'click');
            this.size$ = i(e('#size', this.shadowRoot), 'input')
                .map((event) => Math.round(2 + 38 / 100 * Number(event.target.value)));
            this.size$.dispatch(24);
            i(e('#speed', this.shadowRoot), 'input').subscribe((event) => {
                this.speed = 1000 - Math.sqrt(Number(event.target.value)) * 99;
                if (this.started) {
                    this.play();
                }
            });
            this.speed = 300;
            i(e('#start', this.shadowRoot), 'click').subscribe((event) => {
                this.started = !this.started;
                if (this.started) {
                    event.target.value = 'Stop';
                    this.play();
                }
                else {
                    event.target.value = 'Start';
                    clearInterval(this.timer);
                }
            });
            this.nextGeneration$.subscribe(() => {
                let shape = this.redraw$.value();
                shape = gofNext(shape);
                this.nextShape$.dispatch(shape);
                this.setGeneration(this.generation + 1);
            });
        }
        setGeneration(gen) {
            this.generation = gen;
            e('.generation', this.shadowRoot).textContent = gen.toString(10);
        }
        play() {
            clearInterval(this.timer);
            this.timer = setInterval((event) => {
                this.nextGeneration$.dispatch(event);
            }, this.speed);
        }
        getCollection() {
            return [
                { name: "Clear", data: [] },
                { name: "Glider", data: [[1, 0], [2, 1], [2, 2], [1, 2], [0, 2]] },
                { name: "Small Exploder", data: [[0, 1], [0, 2], [1, 0], [1, 1], [1, 3], [2, 1], [2, 2]] },
                {
                    name: "Exploder",
                    data: [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [2, 0], [2, 4], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4]],
                },
                { name: "10 Cell Row", data: [[0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0], [7, 0], [8, 0], [9, 0]] },
                {
                    name: "Lightweight spaceship",
                    data: [[0, 1], [0, 3], [1, 0], [2, 0], [3, 0], [3, 3], [4, 0], [4, 1], [4, 2]],
                },
                {
                    name: "Tumbler",
                    data: [[0, 3], [0, 4], [0, 5], [1, 0], [1, 1], [1, 5], [2, 0], [2, 1], [2, 2], [2, 3], [2, 4], [4, 0], [4, 1], [4, 2], [4, 3], [4, 4], [5, 0], [5, 1], [5, 5], [6, 3], [6, 4], [6, 5]],
                },
                {
                    name: "Gosper Glider Gun",
                    data: [[0, 2], [0, 3], [1, 2], [1, 3], [8, 3], [8, 4], [9, 2], [9, 4], [10, 2], [10, 3], [16, 4], [16, 5], [16, 6], [17, 4], [18, 5], [22, 1], [22, 2], [23, 0], [23, 2], [24, 0], [24, 1], [24, 12], [24, 13], [25, 12], [25, 14], [26, 12], [34, 0], [34, 1], [35, 0], [35, 1], [35, 7], [35, 8], [35, 9], [36, 7], [37, 8]],
                }
            ];
        }
    }
    customElements.define('gof-controls', GofControls);

    class Shape {
        constructor() {
            this.redraw$ = new s();
            this.current = [];
        }
        init(size$, newShape$, nextShape$, resize$, dimension$, toggle$) {
            dimension$.subscribe((newDimension, oldDimension) => {
                this.offset(newDimension, oldDimension);
            });
            newShape$.subscribe((shape) => {
                this.current = shape.map(cell => [cell[0], cell[1]]);
                this.center(dimension$.value());
                this.redraw();
            });
            nextShape$.subscribe((shape) => {
                this.current = shape;
                this.redraw();
            });
            resize$.subscribe(() => {
                this.redraw();
            });
            toggle$.subscribe((event) => {
                this.toggle([event.cellX, event.cellY]);
            });
        }
        redraw() {
            this.redraw$.dispatch(this.current);
        }
        center(dimension) {
            let shapeWidth = 0;
            let shapeHeight = 0;
            this.current.forEach((cell) => {
                if (cell[0] > shapeWidth) {
                    shapeWidth = cell[0];
                }
                if (cell[1] > shapeHeight) {
                    shapeHeight = cell[1];
                }
            });
            const shapeLeft = Math.round((dimension.width - shapeWidth) / 2);
            const shapeTop = Math.round((dimension.height - shapeHeight) / 2);
            this.current.forEach((cell) => {
                cell[0] += shapeLeft;
                cell[1] += shapeTop;
            });
        }
        offset(dimension, oldDimension) {
            if (oldDimension && dimension.width != oldDimension.width && dimension.height != oldDimension.height) {
                const dx = Math.round((dimension.width - oldDimension.width) / 2.001);
                const dy = Math.round((dimension.height - oldDimension.height) / 2.001);
                this.current.forEach((cell) => {
                    cell[0] += dx;
                    cell[1] += dy;
                });
                this.redraw();
            }
        }
        toggle(toggleCell) {
            const index = this.current.findIndex((cell, index) => cell[0] == toggleCell[0] && cell[1] == toggleCell[1]);
            if (index == -1) {
                this.current.push(toggleCell);
            }
            else {
                this.current.splice(index, 1);
            }
            this.redraw();
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        const canvas = e('gof-canvas');
        const controls = e('gof-controls');
        const info = e('gof-info');
        const shape = new Shape();
        controls.init(shape.redraw$, canvas.click$);
        canvas.init(shape.redraw$, controls.resize$, controls.size$);
        shape.init(controls.size$, controls.newShape$, controls.nextShape$, controls.resize$, canvas.dimension$, canvas.click$);
        info.init(controls.info$);
        if (window.navigator.standalone) {
            document.documentElement.classList.add('standalone');
        }
        // TODO
        console.log(GofCanvas && GofInfo && GofControls && "Game of Life");
    });

}());
//# sourceMappingURL=bundle.min.js.map
